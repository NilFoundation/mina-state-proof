\section{Optimizations}
\label{section:optimizations}
\textbf{WIP}

\subsection{Batched FRI}

Instead of check each commitment individualy, we can aggregate them for FRI.
For polynomials $f_0, \dots, f_k$:
\begin{enumerate}
	\item Get $\theta$ from transcript
	\item $f = f_0 \cdot \theta^{k - 1} + \dots + f_k$
	\item Run FRI over $f$, using oracles to $f_0, \dots, f_k$
\end{enumerate}

Thus, we can run only one FRI instance for all commited polynomials.

See \cite{cryptoeprint:2019:1400} for details.

\subsection{Hash By Column}

Instead of committing each of the polynomials, we can use the same Merkle tree for several polynomials. 
It decreases the number of Merkle tree paths that need to be provided by the prover. 

See \cite{cryptoeprint:2019:1076}, \cite{cryptoeprint:2019:1400} for details.

\subsection{Hash By Subset}

On the each $i + 1$ FRI round, the prover should send all elements from a coset $H \in D^{(i)}$.
Each Merkle leaf is able to contain the whole coset instead of separate values. 

See \cite{cryptoeprint:2019:1076} for details.
Similar approach is described in \cite{cryptoeprint:2019:1400}.
However, the authors of \cite{cryptoeprint:2019:1400} use more values per leaf, that leads to better performance. 